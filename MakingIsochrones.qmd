---
title: "Making Isochrones"
format: html
---

Documentation:

- [Github](https://github.com/traveltime-dev/traveltime-sdk-r)
- [Routes](https://playground.traveltime.com/routes)
- [Isochrones](https://docs.traveltime.com/api/overview/isochrones)

# Plan

Generate map of places in LA you can travel to each venue within different time frames:

- 30 mins, 1hr, and 1.5hrs
- via car and via public transport
- at 8am and 11am on a Weekday

```{r setup}
library(here)
library(tidyverse)
library(sf)
library(traveltimeR)
library(jsonlite)

# Load custom functions
source(here("R", "fct-traveltime.R"))
```

# Data

## Census Tracts


```{r}
# 2020 population by census tract from: https://www.nhgis.org/
nhgis_file = here("data", "nhgis", "nhgis0001_ds258_2020_tract.csv")

nhgis = read_csv(nhgis_file)

nhgis_la = nhgis |> 
  filter(STATE == "California", COUNTY == "Los Angeles County") |> 
  mutate(AREALAND_SQKM = AREALAND/1e6,
         AREALAND_SQMI = AREALAND_SQKM/2.59,
         .after = "AREALAND") |> 
  select(GISJOIN, YEAR, TRACTA, POPULATION = U7H001, AREALAND_SQKM, AREALAND_SQMI)

# Census tract shapefiles
nhgis_shp_file = here("data", "nhgis", "US_tract_2020.shp")

nhgis_shp = st_read(nhgis_shp_file) |> 
  # Reproject CRS to WGS84
  st_transform(crs = "EPSG:4326")

```

Create an opinionated subset of Los Angeles tracts that make up the area of LA where transportation to venues is relevant.

Exclude Catalina Island (tract 5991) and the area north of the San Gabriel Mountains (tract 9304).
Also exclude tracts that are north of the 34.35 latitude: functionally Santa Clarita and above.

```{r}
nhgis_la_shp = inner_join(nhgis_la, nhgis_shp, by = "GISJOIN")

exclude_tracts = tribble(
  ~TRACTCE,
  "599100",
  "599000",
  "930400"
)

nhgis_la_shp_subset = nhgis_la_shp |> 
  anti_join(exclude_tracts, by = "TRACTCE") |> 
  filter(st_coordinates(st_centroid(geometry))[,2] < 34.35) |> 
  st_as_sf()

glimpse(nhgis_la_shp_subset)

st_write(nhgis_la_shp_subset, here("data", "nhgis_la_subset.geojson.json"), driver = "GeoJSON")
```

```{r}
ggplot(nhgis_la_shp_subset)+
  geom_sf(colour = "#333")+
  theme_void()
```

Or census tract by population

```{r}
ggplot(nhgis_la_shp_subset)+
  geom_sf(aes(fill = POPULATION), colour = "#333")+
  scale_fill_continuous(name = "Population", breaks = scales::breaks_pretty(), labels = scales::comma, type = "viridis",
                        guide = guide_colorbar(direction = "horizontal", position = "bottom",
                                               theme = theme(legend.key.width = unit(8, "cm"),
                                                             legend.key.height = unit(.25, "cm"))))+
  theme_void()

```
What are the top 20 most populous tracts?

```{r}
nhgis_la_shp_subset |> 
  arrange(desc(POPULATION)) |> 
  head(20)

nhgis_top_pop = nhgis_la_shp_subset |> 
  slice_max(order_by = POPULATION, n = 20)

nhgis_top_pop |> 
  ggplot()+
  geom_sf(data = nhgis_la_shp_subset, aes(geometry = geometry), fill = "grey")+
  geom_sf(aes(geometry = geometry), fill = "red")+
  theme_void()
```

Create an outline shape

```{r}
nhgis_la_shp_outline = nhgis_la_shp_subset |> 
  st_union()

nhgis_la_shp_outline |> 
  ggplot()+
  geom_sf(aes(geometry=geometry))+
  theme_void()

# st_write(nhgis_la_shp_outline, here("data", "nhgis_la_outline.geojson.json"), driver = "GeoJSON")
```


## Venues

Venues data I compiled: https://docs.google.com/spreadsheets/d/18_P4igWVdnWZpbXPb7ZHEw6vscrD8gNAeu0BfDXmE4k/edit?usp=sharing

I opted to include those that are on the LA28 website.
There might be others that have not been confirmed and the plans seemed to have changed since the 2017 Olympics application documents were written. 


```{r}
venues = read_rds(here("data", "venues_complete.rds"))
```

Some of the venues are at the same address e.g. different stadia in Carson

```{r}
# Distinct addresses for venues
venues_distinct_addresses = distinct(venues, address, .keep_all = T)

venues_distinct_addresses |> 
  ggplot(aes(geometry = venue_geometry)) +
  geom_sf(data = nhgis_la_shp_subset, aes(geometry = geometry), colour = "#333")+
  geom_sf(colour = "blue", size = 3)+
  # geom_sf_text(aes(label = venue), size = 2)+
  theme_void()
```

## Combine the two

Join census tract information to the venues

```{r}
venues_tracts = st_join(venues_distinct_addresses, nhgis_la_shp_subset, join = st_within)

distinct(venues_tracts, TRACTA, .keep_all = T)
```

# Isochrones

## Create API Requests

First, need to calculate the latitude and longitude of the venue addresses.
Next, put them into a list column which works with the `make_search()` function.

```{r}
venues_iso = venues_distinct_addresses |> 
  mutate(lat = st_coordinates(venue_geometry)[,2], 
         lng = st_coordinates(venue_geometry)[,1],
         coords = map2(lat, lng, \(lat, lng) list(lat = lat, lng = lng))) |>
  select(id = venue, coords) |> 
  st_drop_geometry()
```

Create a combination of venues and travel times for isochrone requests

```{r}
iso_request_df = venues_iso |> 
  expand_grid(travel_time = 60*c(30, 60, 90, 120))
```

Create a search object for each venue: public transport

```{r}
venues_iso_search = iso_request_df |> 
    pmap(\(id, coords, travel_time) make_search(id = str_c(id, "_", travel_time), 
                                      travel_time = travel_time, 
                                      arrival_time = "2024-12-18T09:00:00-08:00", 
                                      coords = coords, 
                                      transportation = list(type = "public_transport", 
                                                            walking_time=20*60, 
                                                            pt_change_delay = 120),
                                      level_of_detail = list(scale_type = "simple", level = "medium")))
```

Create a search object for each venue: driving

```{r}
venues_iso_search_drive = iso_request_df |> 
    pmap(\(id, coords, travel_time) make_search(id = str_c(id, "_", travel_time), 
                                      travel_time = travel_time, 
                                      arrival_time = "2024-12-18T09:00:00-08:00", 
                                      coords = coords, 
                                      transportation = list(type = "driving"),
                                      level_of_detail = list(scale_type = "simple", level = "medium")))

```

## Make API Requests

Or load the data

```{r}
isochrones_transit_df = readRDS(here("data", str_c("isochrones_transit", today(), ".Rds")))
isochrones_drive_df = readRDS(here("data", str_c("isochrones_drive", today(), ".Rds")))
```


### Public Transport

```{r}
isochrones_transit_results = map(venues_iso_search, time_map_sf)

isochrones_transit_df = list_rbind(isochrones_transit_results, names_to = "id")

isochrones_transit_venues = isochrones_transit_df |> 
  # filter(venue == sample(venue, 1)) |> 
  inner_join(venues, by = "venue") |> 
  mutate(travel_time_mins = factor(travel_time/60))|> 
  arrange(desc(travel_time))

glimpse(isochrones_transit_df)
```
### Driving

```{r}
isochrones_drive_results = map(venues_iso_search_drive, time_map_sf)

isochrones_drive_df = list_rbind(isochrones_drive_results, names_to = "id")
isochrones_drive_venues = isochrones_drive_df |> 
  # filter(venue == sample(venue, 1)) |> 
  inner_join(venues, by = "venue") |> 
  mutate(travel_time_mins = factor(travel_time/60))|> 
  arrange(desc(travel_time))
```


## Save Isochrone Data

First, save as RDS files to load easily into R

```{r}
# Write Isochrones data
saveRDS(isochrones_transit_df, here("data", str_c("isochrones_transit", today(), ".Rds")))
saveRDS(isochrones_drive_df, here("data", str_c("isochrones_drive", today(), ".Rds")))

```

To make this data accessible in Svelte, I need to convert it to GeoJSON

```{r}
sf::st_as_sf(isochrones_transit_df) |> 
  sf::st_write(here("data", "isochronesTransit.geojson"))

sf::st_as_sf(isochrones_drive_df) |> 
  sf::st_write(here("data", "isochronesDrive.geojson"))
```

## Plot the Isochrones

### Public Transport

```{r}
isochrone_plots = st_as_sf(isochrones_transit_venues) |> 
  split(isochrones_transit_venues$venue) |> 
  map(\(df){
    # Single venue, 3-tier isochrone
  ggplot(df)+
  geom_sf(data = nhgis_la_shp_subset, aes(geometry=geometry), alpha = .9)+
  geom_sf(aes(geometry= geometry, fill = travel_time_mins), alpha = .8)+
  geom_sf(aes(geometry = venue_geometry), alpha = .5, size = 1)+
  geom_sf(data = nhgis_top_pop, aes(geometry = geometry), colour = "blue", fill = NA)+
  # scale_fill_fermenter(breaks = c(29.999, 59.999, 89.999), labels = ~round(.x, 0), type = "div", palette = 8)+
  # scale_fill_steps2(breaks = c(30, 60, 90), n.breaks = 3, nice.breaks = F)+
  scale_fill_brewer(name = "Mins", type = "div", palette = 8, direction = -1, 
                        guide = guide_legend(direction = "horizontal", position = "bottom",
                                               theme = theme(legend.key.width = unit(.75, "cm"), legend.text.position = "bottom",
                                                             legend.key.height = unit(.5, "cm"), legend.title.position = "right")))+
  labs(title = "How long does it take to get to ________ using public transit?",
       subtitle = unique(df$venue),
       caption = "Allows for 20 mins walking to/between transit stops\n\nSource: Traveltime API")+
  theme_void()
  }) |> set_names(unique(isochrones_transit_venues$venue))
  
isochrone_plots
```

### Driving

```{r}

isochrone_plots_drive = st_as_sf(isochrones_drive_venues) |> 
  split(isochrones_drive_venues$venue) |> 
  map(\(df){
    # Single venue, 3-tier isochrone
  ggplot(df)+
  geom_sf(aes(geometry= geometry, fill = travel_time_mins), alpha = .8)+
  geom_sf(aes(geometry = venue_geometry), alpha = .5, size = 1)+
  geom_sf(data = nhgis_top_pop, aes(geometry = geometry), colour = "blue", fill = NA)+
  geom_sf(data = nhgis_la_shp_subset, aes(geometry=geometry), alpha = .7)+
  # scale_fill_fermenter(breaks = c(29.999, 59.999, 89.999), labels = ~round(.x, 0), type = "div", palette = 8)+
  # scale_fill_steps2(breaks = c(30, 60, 90), n.breaks = 3, nice.breaks = F)+
  scale_fill_brewer(name = "Mins", type = "div", palette = 8, direction = -1, 
                        guide = guide_legend(direction = "horizontal", position = "bottom",
                                               theme = theme(legend.key.width = unit(.75, "cm"), legend.text.position = "bottom",
                                                             legend.key.height = unit(.5, "cm"), legend.title.position = "right")))+
  labs(title = "How long does it take to get to ________ using public transit?",
       subtitle = unique(df$venue),
       caption = "Allows for 20 mins walking to/between transit stops\n\nSource: Traveltime API")+
  theme_void()
  }) |> set_names(unique(isochrones_drive_venues$venue))
  
isochrone_plots_drive
```


```{r}
isochrone_plots[[10]] |> 
  ggsave(filename = here("output", "isochrone_sbra.png"), width = 900, height = 600, units = "px", scale = 2.5)
```




# Analyze Population in Range

One way to analyze the accessibility of the venues with isochrones is to measure what proportion of the LA population lives within a certain range.
To do this, I need to pick a particular Isochrone and use a spatial join on census tracts for tracts which intersect. 

## Try Spatial Join on one Isochrone

Pick a particular isocrhone

```{r}
isochrone_ex = isochrones_transit_df |> 
  filter(venue == "Arena Downtown", id == 6) |> 
  mutate(travel_time_mins = travel_time/60, .after = "travel_time") |> 
  group_by(id, venue, travel_time, travel_time_mins, arrival_time, transportation, walking_time, pt_change_delay) |>
  summarise(geometry = st_union(geometry), .groups = "drop") |>
  st_as_sf()

isochrone_ex
```

```{r}
ggplot(isochrone_ex)+
  geom_sf(data = nhgis_la_shp_subset, aes(geometry=geometry), alpha = .9)+
  geom_sf(data = isochrone_ex, aes(geometry = geometry), colour = "black", fill = "white")+
  labs(subtitle = unique(isochrone_ex$venue))+
  theme_void()
```


Join to census tracts

```{r}
isochrone_ex_joined = st_join(y=isochrone_ex, x=nhgis_la_shp_subset, join = st_intersects) |> #glimpse()
  mutate(in_iso = !is.na(travel_time),
         iso_pop = if_else(in_iso, POPULATION, 0),
         pop_pct = sum(iso_pop, na.rm=T)/sum(POPULATION, na.rm=T))
  
isochrone_ex_joined|> 
  ggplot()+
  geom_sf(aes(geometry=geometry, fill = in_iso), alpha = .9)+
  # geom_sf(data = isochrone_ex, aes(geometry = geometry), colour = "black", fill = "black")+
  labs(subtitle = str_c("Travel to ", unique(isochrone_ex$venue), " within ", unique(isochrone_ex$travel_time_mins), " mins: ", scales::percent(unique(isochrone_ex_joined$pop_pct))))+
  theme_void()
  
```

```{r}
st_join(x=isochrone_ex, y=nhgis_la_shp_subset, join = st_intersects) |> 
  group_by(venue, travel_time, travel_time_mins, arrival_time, transportation, walking_time, pt_change_delay) |> 
  summarise(pop = sum(POPULATION),
            pop_pct = pop/sum(nhgis_la_shp_subset$POPULATION), .groups = "drop")
```

## Join Population to Isochrones

Now try to do the same for all the isochrones

```{r}
isochrones_union = isochrones_transit_df |> 
  mutate(travel_time_mins = travel_time/60, .after = "travel_time") |> 
  # Convert multiple individual polygons to single multipolygon
  group_by(id, venue, travel_time, travel_time_mins, arrival_time, transportation, walking_time, pt_change_delay) |>
  summarise(geometry = st_union(geometry), .groups = "drop") |>
  st_as_sf()
```

```{r}
isochrones_pop_joined = isochrones_union |> 
  st_join(y=nhgis_la_shp_subset, join = st_intersects)

isochrones_pop_pct = isochrones_pop_joined |> 
  st_drop_geometry() |> 
  group_by(venue, travel_time, travel_time_mins, arrival_time, transportation, walking_time, pt_change_delay) |>
  summarise(pop = sum(POPULATION),
            pop_pct = pop/sum(nhgis_la_shp_subset$POPULATION), .groups = "drop")
```



```{r}
isochrones_pop_pct |> 
  group_by(travel_time_mins) |> 
  summarise(
    min = min(pop_pct),
    mean = mean(pop_pct),
    median = median(pop_pct),
    max = max(pop_pct)
  )
```

```{r}
isochrones_pop_pct |> 
  mutate(travel_time_fct = factor(travel_time_mins)) |> 
  ggplot(aes(x = travel_time_fct))+
  geom_boxplot(aes(y = pop_pct))+
  geom_point(aes(y = pop_pct))+
  scale_y_continuous(labels = scales::percent)+
  theme_minimal()
```

On average, 75% of the population can reach the Olympic venues within 2 hours.

```{r}
isochrones_pop_pct |> 
  filter(venue == "Sepulveda Basin Recreation Area")
```

Create a stacked bar chart that displays the proportion of the population that can access the venue at each time interval

```{r}
travel_time_stacked = isochrones_pop_pct |> 
  filter(travel_time_mins <= 120) |> 
  group_by(venue) |> 
  mutate(max_pct = max(pop_pct)) |> 
  ungroup() |> 
  arrange(desc(max_pct), venue, desc(travel_time_mins)) |> 
  mutate(travel_time_fct = factor(travel_time_mins, 
                                  levels = c(30, 60, 90, 120, 150), 
                                  labels = c("< 30", "30–60", "60–90", "90–120", "120–150")),
         venue_fct = fct_inorder(factor(venue))) |> 
  ggplot(aes(x = pop_pct))+
  geom_col(aes(y = venue_fct, fill = travel_time_fct), colour = "white", position = position_identity())+
  geom_text(aes(x = max_pct, y = venue_fct, label = scales::percent(max_pct, accuracy = 1)),
            hjust = 0, vjust = .7, alpha = .9, size = 3.25, colour = "darkgrey", nudge_x = .01)+
  scale_x_continuous(name = NULL, labels = scales::percent, expand = expansion(add = .1))+
  scale_fill_brewer(name = "Mins", type = "div", palette = 8, direction = -1, 
                        guide = guide_legend(direction = "horizontal", position = "bottom",
                                               theme = theme(legend.key.width = unit(1.5, "cm"), legend.text.position = "bottom",
                                                             legend.key.height = unit(.5, "cm"), 
                                                             legend.title.position = "right")))+
  labs(y = NULL, title = "How much of LA can access the venues by public transit?", subtitle = "In journeys less than 2 hours")+
  theme_minimal()+
  theme(panel.grid.major.y = element_blank())

travel_time_stacked

travel_time_stacked |> 
  ggsave(filename = here("output", "travel_time_stacked.png"), width = 900, height = 600, units = "px", scale = 2.5)
```

# Analyze 


# Output

Write the isochrone data to GeoJSON

```{r}
isochrones_pop_pct |> 
  select(venue, travel_time, arrival_time, pop, pop_pct) |> 
  right_join(isochrones_union, by = c("venue", "travel_time", "arrival_time")) |> 
  st_write(here("data", "isochronesPop.geojson.json"), driver = "GeoJSON", append = F)

```

