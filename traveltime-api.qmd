---
title: "Traveltime API"
format: html
---

Documentation:

- [Github](https://github.com/traveltime-dev/traveltime-sdk-r)
- [Routes](https://playground.traveltime.com/routes)
- [Isochrones](https://docs.traveltime.com/api/overview/isochrones)

# Plan

1. Generate Isochrones around each venue for accessing the venue via car and via public transport
2. Using Census tracts in Los Angeles, generate routes (and the durations) for each tract to each venue

```{r setup}
library(here)
library(tidyverse)
library(sf)
library(traveltimeR)
library(jsonlite)
```

# Data

## Venues

```{r}
venues = read_rds(here("data", "venues_complete.rds"))
```

```{r}
venues |> 
  ggplot(aes(geometry = venue_geometry)) +
  geom_sf()+
  geom_sf_text(aes(label = venue), size = 2)+
  theme_void()
```
```{r}
venues_distinct_addresses = distinct(venues, address, .keep_all = T)

venues_distinct_addresses |> 
  ggplot(aes(geometry = venue_geometry)) +
  geom_sf()+
  geom_sf_text(aes(label = venue), size = 2)+
  theme_void()
```


## Census Tracts


```{r}
# 2020 population by census tract from: https://www.nhgis.org/
nhgis_file = here("data", "nhgis", "nhgis0001_ds258_2020_tract.csv")

nhgis = read_csv(nhgis_file)

nhgis_la = nhgis |> 
  filter(STATE == "California", COUNTY == "Los Angeles County") |> 
  mutate(AREALAND_SQKM = AREALAND/1e6,
         AREALAND_SQMI = AREALAND_SQKM/2.59,
         .after = "AREALAND") |> 
  select(GISJOIN, YEAR, TRACTA, POPULATION = U7H001, AREALAND_SQKM, AREALAND_SQMI)

# Census tract shapefiles
nhgis_shp_file = here("data", "nhgis", "US_tract_2020.shp")

nhgis_shp = st_read(nhgis_shp_file) |> 
  # Reproject CRS to WGS84
  st_transform(crs = "EPSG:4326")

```

Create an opinionated subset of Los Angeles tracts that make up the area of LA where transportation to venues is relevant.

Exclude Catalina Island (tract 5991) and the area north of the San Gabriel Mountains (tract 9304).
Also exclude tracts that are north of the 34.35 latitude: functionally Santa Clarita and above.

```{r}
nhgis_la_shp = inner_join(nhgis_la, nhgis_shp, by = "GISJOIN")

exclude_tracts = tribble(
  ~TRACTCE,
  "599100",
  "599000",
  "930400"
)

nhgis_la_shp_subset = nhgis_la_shp |> 
  anti_join(exclude_tracts, by = "TRACTCE") |> 
  filter(st_coordinates(st_centroid(geometry))[,2] < 34.35) |> 
  st_as_sf()
```

Join census tract information to the venues

```{r}
venues_tracts = st_join(venues, nhgis_la_shp_subset, join = st_within)

distinct(venues_tracts, TRACTA, .keep_all = T)
```


# Isochrones

[Example on GitHub](https://github.com/traveltime-dev/traveltime-sdk-r?tab=readme-ov-file#isochrones-time-map)

```{r}
dateTime <- strftime(as.POSIXlt(Sys.time(), "UTC"), "%Y-%m-%dT%H:%M:%SZ")

departure_search <-
  make_search(id = "public transport from Trafalgar Square",
              coords = list(lat = 51.507609, lng = -0.128315),
              departure_time = dateTime,
              travel_time = 900,
              transportation = list(type = "public_transport"),
              properties = list('is_only_walking'))

arrival_search <-
  make_search(id = "public transport to Trafalgar Square",
              coords = list(lat = 51.507609, lng = -0.128315),
              arrival_time = dateTime,
              travel_time = 900,
              transportation = list(type = "public_transport"),
              range = list(enabled = TRUE, width = 3600))

result <-
  time_map(
    departure_searches = departure_search,
    arrival_searches = arrival_search
  )

# print(result)

```

```{r}
arrival_search <-
make_search(id = "public transport to Trafalgar Square",
            travel_time = 900,
            coords = list(lat = 51.507609, lng = -0.128315),
            arrival_time_period = "weekday_morning",
            transportation = list(type = "public_transport"))

fast_result <-
time_map_fast(
  arrival_many_to_one = arrival_search
)

# print(result)
```


How to use the result?

```{r}
str(fast_result, max.level = 2)
```


Based on an old API wrapper package, here's how to convert the response to an SF object:

- https://tlorusso.github.io/traveltime/vignette.html#taking-a-glimpse-at-the-isochrones-mapview
- https://github.com/tlorusso/traveltime

```{r, eval=F}
flat <- c(1:length(fast_result$contentParsed$results[[1]]$shapes)) |> 
    purrr::map_dfr(., ~dplyr::bind_rows(fast_result$contentParsed$results[[1]]$shapes[[.x]]$shell),.id="group")

flat_points = sf::st_as_sf(x = flat,
                 coords = c("lng", "lat"),
                 crs = "+proj=longlat +datum=WGS84")

flat_points |> 
    dplyr::mutate(ID=dplyr::row_number()) |> 
    dplyr::group_by(group) |> 
    dplyr::arrange(ID) |> 
    dplyr::summarize(INT = dplyr::first(ID), do_union = FALSE) |> 
    sf::st_cast("POLYGON") |> 
    dplyr::select(-INT)
```

What's it doing?

1. Counting the items in the shapes object

```{r}
result_shapes = fast_result$contentParsed$results[[1]]$shapes

fast_result$contentParsed$results |> 
  str(max.level=4)
```

2. Binding the rows from each shape's "shell" together

```{r}
result_shell = modify(result_shapes, "shell") |> 
  modify_depth(.depth = 2, as_tibble) |> 
  map(list_rbind) |> 
  list_rbind(names_to = "group")

modify(result_shapes, "shell") |> 
  modify_depth(.depth = 2, as_tibble) |>
  map(list_rbind) |> 
  list_rbind(names_to = "group") |> 
  str(max.level=3)
```

3. Converting the data to an sf object

```{r}
result_points = sf::st_as_sf(x = result_shell,
                 coords = c("lng", "lat"),
                 crs = "EPSG:4326")

sf::st_as_sf(x = result_shell,
                 coords = c("lng", "lat"),
                 crs = "EPSG:4326")
```

4. Sorting each shell using a row number
5. Summarizing the data to get the first row number for each group
6. Casting the data to a polygon
7. Removing the intermediate row number

```{r}
result_points |> 
    dplyr::mutate(ID=dplyr::row_number()) |> 
    dplyr::group_by(group) |> 
    dplyr::arrange(ID) |> 
    summarise(INT = dplyr::first(ID),
              geometry = st_cast(st_combine(geometry), "POLYGON"), .groups = "drop") |>
    # dplyr::summarize(INT = dplyr::first(ID), do_union = FALSE) |>
    # sf::st_cast("POLYGON") |>
    dplyr::select(-INT) |> plot()
```
## Fast API endpoint


Write a function to wrap around the API call

```{r}
# Output to emulate
time_map_fast(
  arrival_many_to_one = arrival_search,
  format = "geo+json"
)

time_map_fast_sf = function(arrival){
  arrival_df = list_rbind(arrival)
  # Call the API
  time_map_result = time_map_fast(
    arrival_many_to_one = arrival,
  format = "geo+json"
    )
  
  result_shapes = time_map_result$contentParsed$results[[1]]$shapes
  
  result_shell = modify(result_shapes, "shell") |> 
    modify_depth(.depth = 2, as_tibble) |> 
    map(list_rbind) |> 
    list_rbind(names_to = "group")

  result_points = sf::st_as_sf(x = result_shell,
                               coords = c("lng", "lat"),
                               crs = "+proj=longlat +datum=WGS84") #"EPSG:4326"
  
  result_points |> 
    dplyr::mutate(ID=dplyr::row_number()) |> 
    dplyr::group_by(group) |> 
    dplyr::arrange(ID) |> 
    summarise(
      INT = dplyr::first(ID),
      geometry = st_cast(st_combine(geometry), "POLYGON"), 
      .groups = "drop"
      ) |> 
    # dplyr::summarize(INT = dplyr::first(ID), do_union = FALSE) |> 
    #   sf::st_cast("POLYGON") |> 
    dplyr::select(-INT) |> 
    mutate(venue = arrival_df$id,
           travel_time = arrival_df$travel_time,
           arrival_time_period = arrival_df$arrival_time_period,
           transportation = arrival_df$transportation$type,
           .before = "group")
}

time_map_fast_sf(arrival_search)
```

Now I need to create the arrival search for each venue. 
I will want to modify the following parameters:
- different times of day. ([Can't do this](https://docs.traveltime.com/api/reference/isochrones-fast#arrival_searches-many_to_one-arrival_time_period), `weekday_morning` is the only option)
- different modes of transport (car, public transport)
- set the travel time to 1 hour (3600 seconds) and 2 hours (7200 seconds)

It seems the fast Isochrone endpoint can't support driving requests.
I can use the regular endpoint for driving requests and fast endpoint for public transport requests.


```{r}

venues_iso = venues |> 
  # Only keep one venue per address
  distinct(address, .keep_all = T) |> 
  mutate(lat = st_coordinates(venue_geometry)[,2], 
         lng = st_coordinates(venue_geometry)[,1],
         coords = map2(lat, lng, \(lat, lng) list(lat = lat, lng = lng))) |>
  select(id = venue, coords)

venues_iso_list = list(
  venues_iso$id, 
  venues_iso$coords
  ) |> 
    pmap(\(venue, coords) make_search(id = venue, 
                                      travel_time = 3600, 
                                      arrival_time_period = "weekday_morning", 
                                      coords = coords, 
                                      transportation = list(type = "public_transport"),
                                      level_of_detail = list(scale_type = "simple", level = "high")))
```

Test this for a single venue

```{r}
sample_venue = venues_iso_list[[1]]

sample_isochrone = time_map_fast_sf(sample_venue)

sample_isochrone |> 
  inner_join(as_tibble(venues), by = "venue") |> 
    ggplot()+
  # Map of LA tracts
    geom_sf(data = nhgis_la_shp_subset, aes(geometry = geometry, fill = POPULATION), colour = NA)+
  # Public transport Isochrone
    geom_sf(aes(geometry = geometry), fill = "red", alpha = 0.5)+
  # Venue point
    geom_sf(aes(geometry = venue_geometry), colour = "black")+
    scale_fill_continuous(low = "white", high = "blue")+
    theme_void()
```

This isochrone is a little generous. Within this Isochrone is Westchester, a place I used to live.
Take Beach Pizza on Manchester and Lincoln for example: Beach Pizza, 8601 Lincoln Blvd #150, Westchester, CA 90045
Looking at directions from Beach Pizza to Arena Downtown (AKA: LA Live), I cannot find a public transport route on a weekday morning that is less than 1 hour. It is often close, but always more than an hour.

Does the isochrone from the full API look any different? 
First, I'll need to write another function and a new set of arrival searches.

## Regular API endpoint

```{r}
time_map_sf = function(arrival){
  Sys.sleep(1)
  arrival_df = list_rbind(arrival) |> 
    unnest_wider(transportation, names_sep = "_")
  # Call the API
  time_map_result = time_map(
    arrival_searches = arrival,
    format = "geo+json"
    )
  
  result_shapes = time_map_result$contentParsed$results[[1]]$shapes
  
  result_shell = modify(result_shapes, "shell") |> 
    modify_depth(.depth = 2, as_tibble) |> 
    map(list_rbind) |> 
    list_rbind(names_to = "group")

  result_points = sf::st_as_sf(x = result_shell,
                               coords = c("lng", "lat"),
                               crs = "EPSG:4326") #"+proj=longlat +datum=WGS84"
  
  result_sum = result_points |> 
    dplyr::mutate(ID=dplyr::row_number()) |> 
    dplyr::group_by(group) |> 
    dplyr::arrange(ID) |> 
    summarise(
      INT = dplyr::first(ID),
      geometry = st_cast(st_combine(geometry), "POLYGON"), 
      .groups = "drop"
      ) |> 
    # dplyr::summarize(INT = dplyr::first(ID), do_union = FALSE) |> 
    #   sf::st_cast("POLYGON") |> 
    dplyr::select(-INT)
  
  if(arrival_df$transportation_type == "public_transport"){
    mutate(result_sum,
           id = arrival_df$id,
           venue = str_extract(arrival_df$id, "(?<=to\\s).+"),
           travel_time = arrival_df$travel_time,
           arrival_time = arrival_df$arrival_time,
           transportation = arrival_df$transportation_type,
           walking_time = arrival_df$transportation_walking_time,
           pt_change_delay = arrival_df$transportation_pt_change_delay,
           .before = "group")
  } else {
    mutate(result_sum,
           id = arrival_df$id,
           venue = str_extract(arrival_df$id, "(?<=to\\s).+"),
           travel_time = arrival_df$travel_time,
           arrival_time = arrival_df$arrival_time,
           transportation = arrival_df$transportation_type,
           walking_time = NA_real_,
           pt_change_delay = NA_real_,
           .before = "group")
  }
    
}
```

```{r}
venues_iso_sample_list = list(
  venues_iso$id, 
  venues_iso$coords
  ) |> 
    pmap(\(venue, coords) make_search(id = venue, 
                                      travel_time = 3600, 
                                      arrival_time = "2024-12-03T09:00:00-08:00", 
                                      coords = coords, 
                                      transportation = list(type = "public_transport", 
                                                            walking_time=20*60, 
                                                            pt_change_delay = 120),
                                      level_of_detail = list(scale_type = "simple", level = "medium")))
```


```{r}
venues_isochrones_sample = map(venues_iso_sample_list, time_map_sf)

list_rbind(venues_isochrones_sample, names_to = "id")
```

Test this for a single venue

```{r}
sample_venue_full = venues_isochrones_sample[[1]]

sample_venue_full |> 
  inner_join(venues, by = "venue") |> 
    ggplot()+
  # Map of LA tracts
    geom_sf(data = nhgis_la_shp_subset, aes(geometry = geometry, fill = POPULATION), colour = NA)+
  # Public transport Isochrone
    geom_sf(aes(geometry = geometry), fill = "red", alpha = 0.5)+
  # Venue point
    geom_sf(aes(geometry = venue_geometry), colour = "black")+
    scale_fill_continuous(low = "white", high = "blue")+
    theme_void()
```

This looks a little more realistic.

Now, we want create isochrones for different times of day and for driving.

Create 10 isochrones for each venue:

- 5 times of day: 8am-8pm (every 3 hrs)
- 2 modes of transport: public transport, driving

```{r}
times_of_day = str_c("2024-12-03T", c("08", "11", "14", "17", "20"), ":00:00-08:00")

modes = c("public_transport", "driving")

```

```{r}
variations = expand_grid(venue = venues_iso$id, times_of_day, modes) |> 
  left_join(venues_iso, by = c("venue" = "id"))

variations
```


Use these variations to create the arrival searches

```{r}
venues_iso_full_list = list(
  variations$venue, 
  variations$coords,
  variations$modes,
  variations$times_of_day
  ) |> 
    pmap(\(venue, coords, mode, time) make_search(id = str_c(mode, " to ", venue), 
                                      travel_time = 3600, 
                                      arrival_time = time, 
                                      coords = coords, 
                                      transportation = list(type = mode, 
                                                            walking_time=20*60, 
                                                            pt_change_delay = 120),
                                      level_of_detail = list(scale_type = "simple", level = "medium")))
```


```{r}
venues_isochrones_full = map(venues_iso_full_list, time_map_sf)

venues_isochrones_df = list_rbind(venues_isochrones_full) |> 
  mutate(venue = str_remove_all(venue, "\\s?to\\s"),
         arrival_time = ymd_hms(arrival_time, tz = "America/Los_Angeles")) |> 
  group_by(id, venue, travel_time, arrival_time, transportation, walking_time, pt_change_delay) |>
  summarise(geometry = st_union(geometry), .groups = "drop")

glimpse(venues_isochrones_df)

# saveRDS(venues_isochrones_df, here("data", "venues_isochrones.rds"))
```

```{r}
venues_isochrones_df = readRDS(here("data", "venues_isochrones.rds"))
```


```{r}
venues_isochrones_df |> 
  filter(venue == "Stadium Carson") |> 
    ggplot()+
  # Map of LA tracts
    geom_sf(data = nhgis_la_shp_subset, aes(geometry = geometry, fill = POPULATION), colour = NA)+
  # Public transport Isochrone
    geom_sf(aes(geometry = geometry), fill = "red", alpha = 0.5)+
  # Venue point
    # geom_sf(aes(geometry = venue_geometry), colour = "black")+
    scale_fill_continuous(low = "white", high = "blue")+
  facet_grid(rows = vars(arrival_time), cols = vars(transportation))+
    theme_void()
```

```{r}
show_time_of_day = function(date) stamp("8am on Tuesday", orders = "%I%p %A")(date)
# map isochrones function
map_isochrones = function(data){
  ggplot(data)+
  # Map of LA tracts
    geom_sf(data = nhgis_la_shp_subset, aes(geometry = geometry, fill = POPULATION), colour = NA)+
  # Public transport Isochrone
    geom_sf(aes(geometry = geometry), fill = "red", alpha = 0.5)+
    geom_sf(aes(geometry = venue_geometry), colour = "black", size = 1.5)+
  # Venue point
    # geom_sf(aes(geometry = venue_geometry), colour = "black")+
    scale_fill_continuous(low = "white", high = "blue")+
    labs(title = unique(data$venue))+
  facet_grid(rows = vars(arrival_time), cols = vars(transportation), 
             labeller = labeller(transportation = str_to_title))+
    theme_void()
}


venues_isochrones_df |> 
  left_join(select(venues, venue, venue_geometry), by = "venue") |>
  split(venues_isochrones_df$venue) |> # pluck(1) |> map_isochrones() # Test one
  map(map_isochrones)
```

With isochrones for each venue, we can see which venues are harder to reach by public transit.
Next steps might include:

- creating isochrones for 30 mins, 45 mins, 1.5hrs, 2hrs?
- including weekdays other than Tuesday and weekends

# Routes

Another way to identify areas with poor transit coverage, particularly as it relates to the Olympic venues, is to measure the travel times to each venue from all around Los Angeles.
I tested this out with the Google Maps API and it seemed to work quite well.

The plan is to calculate the centroid of each census tract in the "proper" LA subset I created and measure the distance/travel time to each venue using [TravelTime's Routes API](https://docs.traveltime.com/api/reference/routes).

Similar to the Isochrone API request, I need to use the `make_search()` function and provide:

- departure location
- arrival location
- arrival/departure time
- transportation type
- a list of properties to return (`travel_time`, `distance`, `route`, `fares`)

This means we need the following combinations:

- Census tracts (departure locations) : 2,338
- Venues (arrival locations) : 14
- Departure times: 3 (morning, afternoon, evening) or 6 (weekday, weekend)
- Transportation types: 2 (public transport, driving)

Here is the example [from the GitHub repo](https://github.com/traveltime-dev/traveltime-sdk-r?tab=readme-ov-file#routes)

```{r}
locations <- c(
  make_location(
    id = 'London center',
    coords = list(lat = 51.508930, lng = -0.131387)),
  make_location(
    id = 'Hyde Park',
    coords = list(lat = 51.508824, lng = -0.167093)),
  make_location(
    id = 'ZSL London Zoo',
    coords = list(lat = 51.536067, lng = -0.153596))
)

departure_search <-
  make_search(id = "departure search example",
              departure_location_id = "London center",
              arrival_location_ids = list("Hyde Park", "ZSL London Zoo"),
              departure_time = strftime(as.POSIXlt(Sys.time(), "UTC"), "%Y-%m-%dT%H:%M:%SZ"),
              properties = list("travel_time", "distance", "route"),
              transportation = list(type = "driving"))

arrival_search <-
  make_search(id = "arrival  search example",
              arrival_location_id = "London center",
              departure_location_ids = list("Hyde Park", "ZSL London Zoo"),
              arrival_time = strftime(as.POSIXlt(Sys.time(), "UTC"), "%Y-%m-%dT%H:%M:%SZ"),
              properties = list('travel_time', "distance", "route", "fares"),
              transportation = list(type = "public_transport"),
              range = list(enabled = TRUE, width = 1800, max_results = 1))

result <-
  routes(
    departure_searches = departure_search,
    arrival_searches = arrival_search,
    locations = locations
  )

# print(result)
```

So I need an arrival search which looks like this:

```{r}
# Can define a max of 10 searches
arrival_search_public_transport <-
  make_search(id = "arrival  search example",
              arrival_location_id = "Venue #1",
              departure_location_ids = list("List of Census tracts"),
              arrival_time = strftime(as.POSIXlt(Sys.time(), "UTC"), "%Y-%m-%dT%H:%M:%SZ"),
              properties = list('travel_time', "distance", "route", "fares"),
              transportation = list(type = "public_transport"),
              # Can only use range for public transport
              range = list(enabled = TRUE, width = 600, max_results = 1))

arrival_search_driving <-
  make_search(id = "arrival  search example",
              arrival_location_id = "Venue #1",
              departure_location_ids = list("List of Census tracts"),
              arrival_time = strftime(as.POSIXlt(Sys.time(), "UTC"), "%Y-%m-%dT%H:%M:%SZ"),
              properties = list('travel_time', "distance", "route"),
              transportation = list(type = "driving"))
```

## Locations


Convert venue locations into a list format with:

- venue name as `id`, and
- coordinates as a list with names `lat` and `lng`

```{r}
venues_locations = venues |> 
  # Only keep one venue per address
  distinct(address, .keep_all = T) |> 
  mutate(lat = st_coordinates(venue_geometry)[,2], 
         lng = st_coordinates(venue_geometry)[,1],
         coords = map2(lat, lng, \(lat, lng) list(lat = lat, lng = lng))) |>
  select(id = venue, coords)


venues_locations_list = list(
  venues_locations$id, 
  venues_locations$coords
  ) |> 
    pmap(\(venue, coords) make_location(id = venue, 
                                      coords = coords))# |> 
  # set_names(venues_locations$id)
glimpse(venues_locations_list)


```

Do the same for Census tracts

```{r}
tract_locations = nhgis_la_shp_subset |> 
  group_by(TRACTA) |> 
  summarise(center = st_centroid(geometry), .groups = "drop") |> 
  mutate(lat = st_coordinates(center)[,2], 
         lng = st_coordinates(center)[,1],
         coords = map2(lat, lng, \(lat, lng) list(lat = lat, lng = lng))) |>
  select(id = TRACTA, coords)
  
glimpse(tract_locations)
```

```{r}
tract_locations_list = list(
  id = tract_locations$id,
  coords = tract_locations$coords
) |> 
    pmap(\(id, coords) make_location(id = id, 
                                      coords = coords)) |> 
  list_flatten()# |> 
  # set_names(tract_locations$id)

glimpse(tract_locations_list[1:10])

tract_locations_names = map(tract_locations_list, modify, "id") |> 
  list_flatten() |> 
  list_c()
```

```{r}
supported_tract_locations = supported_locations(tract_locations_list)

# supported_tract_locations$contentParsed |> str(max.level=2)
# 
# supported_tract_locations$contentParsed$locations |> 
#   map(as_tibble) |> list_rbind()

supported_tract_locations$contentParsed |> 
  map_depth(2, as_tibble) |> 
  map(list_rbind)
```


## API Call

To maximize the searches per request I could:

For each venue:

- Specify 10 tracts

```{r}

sample_venue_location = make_location(id = venues_locations$id[[1]], 
                                      coords = venues_locations$coords[[1]])

sample_tract_location = make_location(id = tract_locations$id[[1]], 
                                      coords = tract_locations$coords[[1]])

arrival_search_public_transport <-
  make_search(id = "arrival  search example",
              arrival_location_id = sample_venue_location[[1]][1,1],
              departure_location_ids = modify(sample_tract_location, "id"),
              arrival_time = times_of_day[1],
              properties = list('travel_time', "distance", "route", "fares"),
              transportation = list(type = "public_transport", pt_change_delay = 90),
              # Can only use range for public transport
              range = list(enabled = TRUE, width = 600, max_results = 1))

arrival_search_public_transport
```

```{r}
map(arrival_search_public_transport, keep_at, c("arrival_location_id", "arrival_time", "transportation")) |> 
  list_rbind() |> 
  hoist(transportation, "type", "pt_change_delay")
```


Make an arrival search for a single venue.

```{r}
locations = list_flatten(list(venues_locations_list, tract_locations_list[1:10]))

sample_locations = c(sample_venue_location, sample_tract_location)

result <-
  routes(
    # departure_searches = departure_search,
    arrival_searches = arrival_search_public_transport,
    locations = sample_locations
  )

str(result, max.level = 3)
```
The parsed results return a list of searches. 
Each search has a list of locations, each with a list of properties.

```{r}
parsed_result = result$contentParsed$results

parsed_result |> str(max.level=4)
```

For each location, we want to extract the travel time, distance, route, and fares.

```{r}
parsed_result_locations = parsed_result |> list_flatten() |> pluck("locations")

parsed_result_locations |> str(max.level = 4)
```

```{r}
# For each location, pluck properties
parsed_result_location_properties = modify(parsed_result_locations, "properties") |> list_flatten()

parsed_result_location_properties |> str(max.level = 3)

```

```{r}
# Flatten properties
modify_in(parsed_result_locations, list(1, "properties"), \(props) list_flatten(props)) |> 
  # Keep only travel time and distance
  modify_in(list(1, "properties"), \(props) keep_at(props, c("travel_time", "distance"))) |> 
  map(list_flatten, name_spec = "{inner}") |> 
  map(as_tibble) |> 
  list_rbind()
```


```{r}
parsed_result_location_route = modify(parsed_result_location_properties, "route")# |> list_flatten()

parsed_result_location_route |> str(max.level = 3)
```

```{r}
parsed_result_location_route_parts = modify(parsed_result_location_route, "parts") |> list_flatten()

parsed_result_location_route_parts |> str(max.level = 2)
```

```{r}
part_elements = c("id", "type", "mode", "road", "directions", "distance", "travel_time", "line", "departure_station", "arrival_station")

route_part_df = parsed_result_location_route_parts |> 
  map(keep_at, part_elements) |> #str(max.level=3)
  map(as_tibble) |> 
  list_rbind() |> 
  mutate(travel_time_mins = travel_time/60, .after = "travel_time")

route_part_df
```



```{r}
route_part_df |> 
  group_by(mode) |> 
  summarise(
    route_parts = n(),
    total_distance = sum(distance),
    total_travel_time = sum(travel_time),
    total_travel_time_mins = sum(travel_time_mins)
  )
```


```{r}
parsed_result_location_fares = modify(parsed_result_location_properties, "fares")# |> list_flatten()

parsed_result_location_fares |> str(max.level = 3)
```
```{r}
routes_to_df(
    # departure_searches = departure_search,
    route_arrival_search = arrival_search_public_transport,
    route_locations = sample_locations
  )
```

### Difference from Google Maps

I tested the same directions in Google Maps: [Link](https://www.google.com/maps/dir/34.25947,+-118.293/700+Exposition+Park+Dr,+Los+Angeles,+CA+90037/@34.1376791,-118.4211584,11z/data=!3m1!4b1!4m16!4m15!1m3!2m2!1d-118.293!2d34.25947!1m5!1m1!1s0x80c2c8082da49a5d:0x284a0de27bb78037!2m2!1d-118.2850237!2d34.016109!2m3!6e1!7e2!8j1733212800!3e3!5m1!1e2?entry=ttu&g_ep=EgoyMDI0MTEyNC4xIKXMDSoASAFQAw%3D%3D)

Google Maps estimates the travel time around 87 mins compared to TravelTime's 83.
Interestingly, TravelTime's directions have the route get off the 409 bus 4 stops earlier and get on the Expo line at an earlier station (Grand Ave Arts instead of 7th St/Metro Center).
This requires a 5 minute walk from 7:20-7:25 to catch a 7:25 train. 
This might be a little optimistic, so it could be worth adding a 1 minute transfer delay.

The output is:

A list of searches, each with a list of locations, each with a list of properties.
Within properties, we get the travel time, distance, route, and fares.

### Test Multiple departure locations

```{r}
sample_tract_location = make_location(id = tract_locations$id[[1]], 
                                      coords = tract_locations$coords[[1]])
sample_tract_locations = tract_locations_list[c(1,3)]

multiple_arrival_search_public_transport <-
  make_search(id = "arrival multiple search example",
              arrival_location_id = sample_venue_location[[1]][1,1],
              departure_location_ids = as.list(tract_locations_names[c(1,3)]),
              arrival_time = times_of_day[1],
              properties = list('travel_time', "distance", "route", "fares"),
              transportation = list(type = "public_transport", pt_change_delay = 90),
              # Can only use range for public transport
              range = list(enabled = TRUE, width = 600, max_results = 1))

multiple_arrival_search_public_transport
```

```{r}

multiple_sample_locations = c(sample_venue_location, list_flatten(sample_tract_locations))

multiple_result <-
  routes(
    # departure_searches = departure_search,
    arrival_searches = multiple_arrival_search_public_transport,
    locations = multiple_sample_locations
  )

str(multiple_result, max.level = 3)
```

```{r}
parsed_multiple_result = multiple_result$contentParsed$results

parsed_multiple_result |> str(max.level=4)
```


```{r}
routes_to_df(
    # departure_searches = departure_search,
    route_arrival_search = multiple_arrival_search_public_transport,
    route_locations = multiple_sample_locations
  )
```

### Test Multiple Searches

If we can run up to 10 search objects in an API call, we can run a search for a venue with two departure locations => 20 results per call.


```{r}
multiple_searches = list_flatten(venues_locations_list)[1:10] |> 
  map_chr(pluck, "id") |> 
  map(\(venue) make_search(id = str_c(venue, " - arrival multiple search example"),
              arrival_location_id = venue,
              departure_location_ids = modify(sample_tract_locations, pluck, "id"),
              arrival_time = times_of_day[1],
              properties = list('travel_time', "distance", "route", "fares"),
              transportation = list(type = "public_transport", pt_change_delay = 90),
              # Can only use range for public transport
              range = list(enabled = TRUE, width = 600, max_results = 1))) |> 
  list_flatten()
```

```{r}
multiple_search_locations = c(list_flatten(venues_locations_list)[1:10], list_flatten(sample_tract_locations))

multiple_searches_result <-
  routes(
    # departure_searches = departure_search,
    arrival_searches = multiple_searches,
    locations = multiple_search_locations
  )
```


```{r}
routes_to_df(
    # departure_searches = departure_search,
    route_arrival_search = multiple_searches,
    route_locations = multiple_search_locations
  )
```

I can include up to 10 searches in a single API call, but each search can only have 2 departure locations.

To reduce the API calls, I can create sets of 2 departure locations from all the census tracts

```{r}
tract_locations_list |> 
  glimpse()

length(tract_locations_list)/2

imap(tract_locations_list, group = ceiling(seq_along(tract_locations_list)/2))
```

Or...lazily, I could just run a search for each tract

```{r}
venue_ids = list_flatten(venues_locations_list)[1:10] |> 
  map_chr(pluck, "id")
tract_ids = map_chr(tract_locations_list, pluck, "id")


route_searches_1 = expand_grid(venue = venue_ids, tract = tract_ids) |>
  pmap(\(venue, tract) make_search(id = str_c(tract, " to ", venue),
              arrival_location_id = venue,
              departure_location_ids = as.list(tract),
              arrival_time = times_of_day[1],
              properties = list('travel_time', "distance", "route", "fares"),
              transportation = list(type = "public_transport", pt_change_delay = 90),
              # Can only use range for public transport
              range = list(enabled = TRUE, width = 600, max_results = 1))) |> 
  list_flatten()
```

```{r}
routes_to_df(
    # departure_searches = departure_search,
    route_arrival_search = multiple_searches,
    route_locations = multiple_search_locations
  )
```



